# 条款19-设计class犹如设计type
---
+ 当我们利用C++中的`Object-C`部分时，我们应当把自己作为一个type设计者去设计class。

如何设计好class，下面的问答至关重要：

+ 新的type对象应该如何被创建和销毁？
	+ 这会影响你class的构造函数和析构函数以及内存分配函数和释放函数(`operator new`， `operator new[]`， `operator delete`，`operator delete[]`，见第八章)的设计，如果你打算编写他们。

+ 对象的初始化和对象的赋值应该有什么样的却别？
	+ 这个答案决定你的构造函数和赋值操作符的行为，以及其间的差异。不能混淆“初始化”和“赋值”，因为他们对应了不同函数的调用(见[[04-确定对象被使用前已被初始化]])。

+ 新type的对象如果被`pass-by-value`，意味着什么？
	+ copy构造函数用来定义一个type的`pass-by-value`该如何实现

+ 什么是新type的合法值？
	+ 对class的成员变量而言，通常只有某些数值才是有效的。这些数值决定了你的class必须维护的约束条件，同时决定了你的成员函数(构造函数、赋值操作符、setter函数)必须进行错误检查操作。同时也会影响函数抛出的异常、及函数异常明细列。

+ 新type是否需要配合某个继承图系？
	+ 如果你继承自某些class,你就受到那些class设计的束缚，尤其受到其class中的函数是`virtual`还是`non-virtual`的影响(见[[34-区分接口继承和实现继承]]和[[36-绝不重新定义继承而来的non-virtual函数]])。如果你设计的class还需要被其他class继承，你要考虑你的析构函数是否应该为`virtual`(见[[07-为多态基类声明virtual析构函数]])

+ 新type需要什么样的转换？
	+ 新type与其他type共存，因而彼此之间是否应该有转换行为？如果你希望允许隐式转换(T1->T2)，就必须在`class T1`内写一个类型转换函数`operator T2()`，或在`class T2`内写一个`non-explicit-one- argument`的构造函数。如果你只允许`explicit`构造函数存在，就得写出专门负责执行转换的函数，且不得为类型转换操作符(`type conversion operator`)或`non-explicit-one-argument`构造函数。([[15-在资源管理类中提供对原始资源的访问]]中有隐式和显示转换函数的范例)。

+ 什么养的操作符和函数对新type而言是合理的？
	+ 答案决定你为你的class声明哪些函数。其中某些是member函数，某些不是(见[[23-宁以non-menber、non-friend替代menber函数]]，[[24-若所有参数皆需类型转换，请为此采用non-member函数]]，[[46-需要类型转换时请为模板定义非成员函数]])。

+ 什么样的标准函数应该驳回？
	+ 你必须声明为`private`的函数([[06-若不想使用编译器自动生成的函数，就该明确拒绝]])。

+ 谁该取新type的成员？
	+ 答案决定哪个成员为`public`，`protected`，`private`。也决定哪个class或function为`friend`，及嵌套是否合理。

+ 什么是新type的未声明接口？
	+ 对效率、异常安全性([[29-为“异常安全”而努力是值得的]])以及资源运用提供何种保证？你在这方面上提供的保证会将你的class的实现代码加上约束条件。

+ 新type有多么一般化？
	+ 或许你并非定义一个新type，而是一个新type家族。若是如此，你该定义的不是一个class，而是一个class template。

+ 你真的需要一个新type吗？
	+ 若定义新的derived class只是添加了某些功能，是否定义一个或多个non-member函数或template效果更好。

+ 小结：
	+ class的设计就是type的设计。定义一个新type之前，请先思考上述的讨论主题。